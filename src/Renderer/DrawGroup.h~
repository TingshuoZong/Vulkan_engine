#pragma once

#include "shared.inl"
#include "DrawableMesh.h"

#include <daxa/daxa.hpp>
#include <daxa/utils/pipeline_manager.hpp>
#include <daxa/utils/task_graph.hpp>

struct DrawGroup {
	std::string name;
	std::vector<std::weak_ptr<DrawableMesh>> meshes;
	std::shared_ptr<daxa::RasterPipeline> pipeline;

	daxa::Device& device;

	DrawGroup(daxa::Device& device, const std::shared_ptr<daxa::RasterPipeline> &pipeline, std::string name);
	void cleanup();

	template<size_t VertexCount, size_t IndexCount>
	void register_mesh(std::weak_ptr<DrawableMesh> drawableMesh, daxa::TaskGraph loop_task_graph, const std::array<MyVertex, VertexCount> vertex_data, const std::array<uint32_t, IndexCount>& index_data);
	template<size_t VertexCount, size_t IndexCount>
	void update_mesh(uint32_t mesh_index, daxa::TaskGraph& loop_task_graph, const std::array<MyVertex, VertexCount>& vertex_data, const std::array<uint32_t, IndexCount>& index_data);

	void add_mesh_instance(uint32_t mesh_index, PerInstanceData data);

	inline void use_in_loop_task_graph(uint32_t mesh_index, daxa::TaskGraph& loop_task_graph) {
        loop_task_graph.use_persistent_buffer(meshes[mesh_index].lock()->task_vertex_buffer);
        loop_task_graph.use_persistent_buffer(meshes[mesh_index].lock()->task_index_buffer);
        loop_task_graph.use_persistent_buffer(meshes[mesh_index].lock()->task_instance_buffer);
    };

private:
	
};


template<size_t VertexCount, size_t IndexCount>
void DrawGroup::register_mesh(std::weak_ptr<DrawableMesh> drawableMesh, daxa::TaskGraph loop_task_graph, const std::array<MyVertex, VertexCount> vertex_data, const std::array<uint32_t, IndexCount>& index_data) {
	auto upload_task_graph = daxa::TaskGraph({
		.device = device,
		.name = this->name + ">" + drawableMesh.lock()->name + " upload",
	});

    upload_task_graph.use_persistent_buffer(drawableMesh.lock()->task_vertex_buffer);
    upload_task_graph.use_persistent_buffer(drawableMesh.lock()->task_index_buffer);

	drawableMesh.lock()->upload_mesh_data_task<VertexCount, IndexCount>(upload_task_graph, vertex_data, index_data);

	upload_task_graph.submit({});
	upload_task_graph.complete({});
	upload_task_graph.execute({});

	meshes.push_back(drawableMesh);
	use_in_loop_task_graph(meshes.size() - 1, loop_task_graph);
}
