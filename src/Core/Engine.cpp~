#include "Engine.h"

#include "window.h"
#include "shared.inl"

#include "Renderer/Meshes/DrawableMesh.h"
#include "Renderer/Meshes/DrawGroup.h"
#include "Renderer/Meshes/ManagedMesh.h"
#include "Renderer/Textures/TextureHandle.h"
#include "Renderer/Renderer.h"
#include "Renderer/MeshManager.h"

#include "Core/Camera.h"

#include "Engine/InputSystem/InputSystem.h"

#include "Tools/Model_loader.h"

#include "ECS/ECS.h"

#include "Transform/Transform_component.h"

#include <daxa/daxa.hpp>
#include <daxa/utils/pipeline_manager.hpp>
#include <daxa/utils/task_graph.hpp>

#include <iostream>

constexpr float MAX_DELTA_TIME = 0.1f;

int init() {
    auto window = GLFW_Window::AppWindow("Hur Dur", 1600, 900);

    daxa::Instance instance = daxa::create_instance({});

    daxa::Device device = instance.create_device_2(instance.choose_device({}, {}));

    Renderer renderer = Renderer(window, device, instance);
    renderer.loop_task_graph = daxa::TaskGraph({
        .device = device,
        .swapchain = renderer.swapchain,
        .name = "loop",
    });
    renderer.init();

    std::shared_ptr<daxa::RasterPipeline> pipeline;
    {
        auto result = renderer.pipeline_manager.add_raster_pipeline2({
            .vertex_shader_info = daxa::ShaderCompileInfo2{.source = daxa::ShaderFile{"main.vert.glsl"}, .defines = { {"DAXA_SHADER", "1"}, {"GLSL", "1"}} },
            .fragment_shader_info = daxa::ShaderCompileInfo2{.source = daxa::ShaderFile{"main.frag.glsl"}, .defines = { {"DAXA_SHADER", "1"}, {"GLSL", "1"}} },
            .color_attachments = {{.format = renderer.swapchain.get_format()}},
            .depth_test = daxa::DepthTestInfo{
                .depth_attachment_format = daxa::Format::D32_SFLOAT,
                .enable_depth_write = true,                      // enable writing to depth buffer
                .depth_test_compare_op = daxa::CompareOp::LESS_OR_EQUAL,
                .min_depth_bounds = 0.0f,
                .max_depth_bounds = 1.0f,
            },
            .raster = daxa::RasterizerInfo{
                .face_culling = daxa::FaceCullFlagBits::BACK_BIT, // Optional but recommended
                .front_face_winding = daxa::FrontFaceWinding::COUNTER_CLOCKWISE, // Adjust to match your index winding
            },
            .push_constant_size = sizeof(PushConstant),
            .name = "my pipeline",
            });

        if (result.is_err()) {
            std::cerr << result.message() << std::endl;
            return -1;
        }
        pipeline = result.value();
    }

    daxa::SamplerId sampler = device.create_sampler({
        .magnification_filter = daxa::Filter::LINEAR,
        .minification_filter = daxa::Filter::LINEAR,
        .mipmap_filter = daxa::Filter::LINEAR,
        .address_mode_u = daxa::SamplerAddressMode::REPEAT,
        .address_mode_v = daxa::SamplerAddressMode::REPEAT,
    });
// -----------------------------------------------------------------------------------------------------------------
    MeshManager meshManager(device);
    DrawGroup drawGroup(device, pipeline, "My DrawGroup");
    TextureHandle texture1 = TextureHandle(device);
    daxa::ImageViewId view1;

    std::vector<Entity> avocadoEntities;
    avocadoEntities.push_back(EntityManager::createEntity());

    ecs::entityManager.registerComponentManager<ManagedMesh>();    
    auto& meshComponenetManager = ecs::entityManager.getComponentManager<ManagedMesh>();

    ecs::entityManager.registerSystem<TransformSystem>(device, meshComponenetManager);

    {
        GLTF_Loader loader;
        loader.OpenFile("C:/dev/Engine_project/assets/Avocado_glTF/Avocado.gltf"); //"C:/dev/Engine_project/assets/Cursed_Mwerpy_glTF/Untitled.gltf"
        loader.LoadModel();

        if (loader.albedo.has_value()) {
            texture1.stream_texture_from_data(loader.albedo.value(), "Avocado texture");
            view1 = texture1.load_texture(renderer.loop_task_graph);
        }

        // TextureData avocadoTexutreData = {texture1, view1};
        ecs::getComponentManager<ManagedMesh>().addComponent(avocadoEntities[0], ManagedMesh(loader, meshManager, drawGroup, renderer, {view1, sampler}));
        ecs::getComponent<ManagedMesh>(avocadoEntities[0])->getInstanceData().model_matrix = glm::scale(glm::mat4(1.0f), glm::vec3(25.0f));

        auto* ptr = device.buffer_host_address_as<PerInstanceData>(drawGroup.meshes[0].lock()->instance_buffer_id).value();
        memcpy(ptr, ecs::entityManager.getComponentManager<ManagedMesh>().getComponent(avocadoEntities[0])->mesh.lock()->instance_data.data(), drawGroup.meshes[0].lock()->instance_data.size() * sizeof(PerInstanceData));
    }

    int grid_size = 10;
	float spacing = 0.08f;
    
    {
    
        for (int x = 0; x < grid_size; ++x) {
            for (int y = 0; y < grid_size; ++y) {
                for (int z = 0; z < grid_size; ++z) {
                    glm::vec3 position = glm::vec3(
                        (x - grid_size / 2) * spacing,
                        (y - grid_size / 2) * spacing,
                        (z - grid_size / 2) * spacing
                    );
                    int entityIndex = x * grid_size * grid_size + y * grid_size + z;

                    if (entityIndex != 0) {
                        avocadoEntities.push_back(EntityManager::createEntity());
                        ecs::getComponent<ManagedMesh>(avocadoEntities[0])->instantiate(avocadoEntities[entityIndex], meshComponenetManager, { view1, sampler });
                    }

                    glm::mat4 model_matrix;
                    model_matrix = glm::scale(glm::translate(glm::mat4(1.0f), position), glm::vec3(1.0f));
                    ecs::getComponent<ManagedMesh>(avocadoEntities[entityIndex])->getInstanceData().model_matrix = model_matrix;
                }
            }
        }
    
        auto* ptr = device.buffer_host_address_as<PerInstanceData>(drawGroup.meshes[0].lock()->instance_buffer_id).value();
        memcpy(ptr, drawGroup.meshes[0].lock()->instance_data.data(), drawGroup.meshes[0].lock()->instance_data.size() * sizeof(PerInstanceData));
    
    }

    std::vector<DrawGroup> drawGroups;
    drawGroups.push_back(drawGroup);
    //drawGroups.push_back(drawGroup2);
    renderer.drawGroups.push_back(drawGroup);
    //renderer.drawGroups.push_back(drawGroup2);

    renderer.submit_task_graph();

    Camera camera;
    camera.update_vectors();

    auto* glfw_window = window.get_glfw_window();
    //glfwSetWindowUserPointer(glfw_window, &camera);
    window.camera_ptr = &camera;
    glfwSetCursorPosCallback(glfw_window, InputSystem::mouse_callback);

    // Capture the mouse cursor (optional)
    window.set_mouse_capture(true);

    auto last_frame_time = static_cast<float>(glfwGetTime());

    // Main loop
    while (!window.should_close()) {
        auto current_time = static_cast<float>(glfwGetTime());

        float delta_time = current_time - last_frame_time;
        if (delta_time > MAX_DELTA_TIME) delta_time = MAX_DELTA_TIME;

        last_frame_time = current_time;

        window.update();

        InputSystem::process_input(window.get_glfw_window(), camera, delta_time);
        
        renderer.startFrame(camera);

        ecs::getSystem<TransformSystem>()

        // ------------------------------------------------------ Goofy ahh test stuff ------------------------------------------------------
        for (int x = 0; x < grid_size; ++x) {
            for (int y = 0; y < grid_size; ++y) {
                for (int z = 0; z < grid_size; ++z) {
                    glm::vec3 position = glm::vec3(
                        (x - grid_size / 2) * spacing,
                        (y - grid_size / 2) * spacing,
                        (z - grid_size / 2) * spacing
                    );
                    int cubeIndex = x * grid_size * grid_size + y * grid_size + z;
                    float speed = 0.04f * static_cast<float>(cubeIndex); // Unique speed per instance
                    float angle = current_time * speed;
                    drawGroup.meshes[0].lock()->instance_data[cubeIndex].model_matrix = glm::scale(glm::translate(glm::mat4(1.0f), position) * glm::rotate(glm::mat4(1.0f), angle, glm::vec3(0, 1, 0)), glm::vec3(1.0f));
                }
            }
        }
        auto* ptr = device.buffer_host_address_as<PerInstanceData>(drawGroup.meshes[0].lock()->instance_buffer_id).value();
        std::memcpy(ptr, drawGroup.meshes[0].lock()->instance_data.data(), drawGroup.meshes[0].lock()->instance_data.size() * sizeof(PerInstanceData));
        // ------------------------------------------------------- Goofy ahh test stuff ------------------------------------------------------

        renderer.endFrame();
    }

    texture1.cleanup();
    //texture2.cleanup();

    device.destroy_sampler(sampler);

    renderer.cleanup();


    device.wait_idle();
    device.collect_garbage();

    return 0;
}